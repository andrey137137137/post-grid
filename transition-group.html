<!DOCTYPE html>
<html>
  <head>
    <title>List Move Transitions Sudoku Example</title>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"></script>
    <style>
      .container {
        display: grid;
        grid-auto-flow: dense;
        margin: 10px auto 0;
        width: 300px;
        height: 200px;
      }
      .cell {
        position: relative;
        display: flex;
        justify-content: space-around;
        align-items: center;
        box-sizing: border-box;
        border: 1px solid black;
      }
      .cell-large--md {
        grid-row-end: 2 span;
      }
      .cell-large--lg {
        grid-row-end: 2 span;
        grid-column-end: 2 span;
      }
      .cell-large--xl {
        grid-row-end: 2 span;
        grid-column-end: 2 span;
      }
      .cell-move {
        transition: all 1s;
      }
    </style>
  </head>
  <body>
    <div id="post-grid-demo" class="demo">
      <transition-group name="cell" tag="div" class="container" :style="columnSizeStyle">
        <div
          v-for="(cell, index) in cells"
          :key="cell"
          :class="classes(index)"
          :style="evenPreLargeStyle(index)"
        >
          {{ cell }}
        </div>
      </transition-group>
    </div>

    <script>
      new Vue({
        el: "#post-grid-demo",
        data: {
          totalWidth: 0,
          timeoutID: 0,
          rowSize: 3,
          rowStep: 4,
          cellStep: 6,
          cellHeight: 100,
          cellID: -1,
          breakpoints: {
            xl: 1200,
            lg: 922,
            md: 768,
          },
          firstFoundIndexes: {
            large: -1,
            high: -1,
            small: -1,
          },
          cells: [],
        },
        computed: {
          isLessThenMD: function () {
            return this.totalWidth < this.breakpoints.md;
          },
          isLessThenLG: function () {
            return this.totalWidth < this.breakpoints.lg;
          },
          isLessThenXL: function () {
            return this.totalWidth < this.breakpoints.xl;
          },
          columnSizeStyle: function () {
            return {
              "grid-template":
                "repeat(" +
                Math.ceil(this.cells.length / this.rowSize) * 2 +
                ", " +
                this.cellHeight +
                "px) / repeat(" +
                this.rowSize +
                ", 1fr)",
            };
          },
        },
        methods: {
          isLargeCell: function (index) {
            const isEven = index % 2 == 0;
            const isThreeMultiple = index % 3 == 0;

            if (!this.isLessThenXL) {
              return isEven && isThreeMultiple;
            } else {
              return isThreeMultiple;
            }
          },
          evenPreLargeStyle: function (index) {
            if (this.isLessThenXL) return "";
            if (!this.isLargeCell(index + 2)) return "";

            return {
              "grid-row-start": Math.ceil(index / this.cellStep) * this.rowStep,
              "grid-column-start": 1,
            };
          },
          classes: function (index) {
            return {
              cell: true,
              "cell-large--md":
                !this.isLessThenMD && this.isLessThenLG && this.cells[index].size > 2,
              "cell-large--lg":
                !this.isLessThenLG && this.isLessThenXL && this.cells[index].size > 2,
              "cell-large--xl": !this.isLessThenXL && this.cells[index].size > 2,
            };
          },
          isLargeSizeByIndex: function (index) {
            if (this.isLessThenMD) {
              return false;
            }

            if (this.isLessThenXL) {
              return this.isLargeCell(index);
            }

            return this.isLargeCell(index) || this.isLargeCell(index + 1);
          },
          getSizeName: function (size) {
            switch (size) {
              case 1:
                return "small";
              case 2:
                return "high";
              default:
                return "large";
            }
          },
          resetFirstFoundIndex: function (size) {
            this.firstFoundIndexes[this.getSizeName(size)] = -1;
          },
          setFirstFoundIndex: function (size, index) {
            const prop = this.getSizeName(size);

            if (this.firstFoundIndexes[prop] < 0) {
              this.firstFoundIndexes[prop] = index;
            }
          },
          getFirstFoundIndex: function (size) {
            const prop = this.getSizeName(size);

            if (this.firstFoundIndexes[prop] < 0) return 0;

            return this.firstFoundIndexes[prop];
          },
          config: function () {
            this.totalWidth = window.innerWidth;

            if (this.totalWidth >= this.breakpoints.xl) {
              this.rowSize = 3;
            } else if (this.totalWidth >= this.breakpoints.lg) {
              this.rowSize = 2;
            } else if (this.totalWidth >= this.breakpoints.md) {
              this.rowSize = 1;
            } else {
              this.rowSize = 1;
            }
          },
        },
        created() {
          const sourceArray = [
            { size: 2 },
            { size: 4 },
            { size: 1 },
            { size: 4 },
            { size: 1 },
            { size: 1 },
            { size: 4 },
            { size: 1 },
          ];
          let toScaleDownLargeSizes = false;
          let isNotFoundSize = false;
          let findingSize;
          let calcSize;
          let isSmallSequence = false;
          let curIndex = 0;
          let sourceIndex;
          let sourceArrayLength = sourceArray.length;
          let sortedCount = 0;

          this.config();

          while (sortedCount < sourceArrayLength) {
            if (!isNotFoundSize) {
              if (this.isLargeSizeByIndex(curIndex)) {
                findingSize = 4;
              } else if (isSmallSequence) {
                isSmallSequence = false;
                findingSize = 1;
              } else {
                findingSize = 0;
              }
            } else {
              sourceIndex = 0;
              isNotFoundSize = false;
            }

            if (!findingSize) {
              sourceIndex = 0;
            } else {
              sourceIndex = this.getFirstFoundIndex(findingSize);
            }

            for (; sourceIndex < sourceArrayLength; sourceIndex++) {
              if (Object.prototype.hasOwnProperty.call(sourceArray[sourceIndex], "sorted")) {
                continue;
              }

              if (!findingSize && sourceArray[sourceIndex].size < 3) {
                findingSize = sourceArray[sourceIndex].size;

                if (findingSize == 1) {
                  isSmallSequence = true;
                }
              }

              if (findingSize == sourceArray[sourceIndex].size || toScaleDownLargeSizes) {
                calcSize = toScaleDownLargeSizes ? findingSize : sourceArray[sourceIndex].size;

                curIndex++;
                sortedCount++;

                this.cells.push({
                  key: ++this.cellID,
                  sourceSize: sourceArray[sourceIndex].size,
                  calcSize: calcSize,
                });

                this.resetFirstFoundIndex(findingSize);
                sourceArray[sourceIndex].sorted = true;
                break;
              } else {
                setFirstFoundIndex(sourceArray[sourceIndex].size, sourceIndex);
              }
            }

            if (sourceIndex >= sourceArrayLength) {
              toScaleDownLargeSizes = true;
              isNotFoundSize = true;
            }
          }
        },
        mounted() {
          $vm = this;

          window.addEventListener("resize", function () {
            if ($vm.timeoutID) {
              clearTimeout($vm.timeoutID);
            }
            $vm.timeoutID = setTimeout(function () {
              $vm.config();
            }, 200);
          });
        },
      });
    </script>
  </body>
</html>
