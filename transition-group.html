<!DOCTYPE html>
<html>
  <head>
    <title>List Move Transitions Sudoku Example</title>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"></script>
    <style>
      ul {
        padding-left: 10px;
        list-style-type: none;
        list-style-position: inside;
      }
      .container {
        display: grid;
        grid-auto-flow: dense;
        margin: 10px auto 0;
        width: 300px;
        color: white;
      }
      .cell {
        display: flex;
        align-items: center;
        box-sizing: border-box;
        border: 1px solid white;
      }
      .cell-small {
        border: 1px solid black;
        color: black;
      }
      .cell-high--bg {
        background-color: #005f;
      }
      .cell-large--bg {
        background-color: #070;
      }
      .cell-high {
        grid-row-end: 2 span;
      }
      .cell-large--md {
        grid-row-end: 2 span;
      }
      .cell-large--lg {
        grid-row-end: 2 span;
        grid-column-end: 2 span;
      }
      .cell-large--xl {
        grid-row-end: 2 span;
        grid-column-end: 2 span;
      }
      .cell-move {
        transition: all 1s;
      }
    </style>
  </head>
  <body>
    <div id="post-grid-demo" class="demo">
      <transition-group
        name="cell"
        tag="div"
        class="container"
        :style="columnSizeStyle"
      >
        <div
          v-for="(cell, index) in cells"
          :key="cell.key"
          :class="classes(index)"
          :style="evenBeforeLargeStyle(index)"
        >
          <ul>
            <li>key: {{ cell.key }}</li>
            <li>sourceSize: {{ cell.sourceSize }}</li>
            <li>calcSize: {{ cell.calcSize }}</li>
          </ul>
        </div>
      </transition-group>
    </div>

    <script>
      new Vue({
        el: "#post-grid-demo",
        data: {
          totalWidth: 0,
          timeoutID: 0,
          cols: 3,
          firstIndexBeforeEvenLarge: 4,
          cellHeight: 100,
          cellID: -1,
          breakpoints: {
            xl: 1200,
            lg: 922,
            md: 768,
          },
          firstFoundIndexes: {
            large: -1,
            high: -1,
            small: -1,
          },
          largesCount: 0,
          highsCount: 0,
          smallsCount: 0,
          lastHighsCount: 0,
          isLastHigh: false,
          cells: [],
        },
        computed: {
          cellsCountInBlock: function () {
            if (this.isLessThenMD) return 1;
            if (this.isLessThenLG) return 4;
            return 6;
          },
          isLessThenMD: function () {
            return this.totalWidth < this.breakpoints.md;
          },
          isLessThenLG: function () {
            return this.totalWidth < this.breakpoints.lg;
          },
          isLessThenXL: function () {
            return this.totalWidth < this.breakpoints.xl;
          },
          columnSizeStyle: function () {
            return {
              "grid-template":
                "repeat(" +
                Math.ceil(this.cells.length / this.cols) * 2 +
                ", " +
                this.cellHeight +
                "px) / repeat(" +
                this.cols +
                ", 1fr)",
            };
          },
        },
        methods: {
          isLargeCell: function (index) {
            const isEven = index % 2 == 0;
            const isThreeMultiple = index % 3 == 0;

            if (!this.isLessThenXL) return isEven && isThreeMultiple;

            return isThreeMultiple;
          },
          evenBeforeLargeStyle: function (index) {
            if (this.isLessThenXL) return "";
            if (!this.cells[index].beforeEvenLarge) return "";

            return {
              "grid-row-start": this.cells[index].beforeEvenLarge,
              "grid-column-start": 1,
            };
          },
          classes: function (index) {
            return {
              cell: true,
              "cell-small": this.cells[index].sourceSize == 1,
              "cell-high--bg": this.cells[index].sourceSize == 2,
              "cell-large--bg": this.cells[index].sourceSize == 4,
              "cell-high":
                !this.isLessThenXL && this.cells[index].calcSize == 2,
              "cell-large--md":
                !this.isLessThenMD &&
                this.isLessThenLG &&
                this.cells[index].calcSize == 4,
              "cell-large--lg":
                !this.isLessThenLG &&
                this.isLessThenXL &&
                this.cells[index].calcSize == 4,
              "cell-large--xl":
                !this.isLessThenXL && this.cells[index].calcSize == 4,
            };
          },
          isLargeSizeByIndex: function (index) {
            if (this.isLessThenMD) {
              return false;
            }

            if (this.isLessThenXL) {
              return this.isLargeCell(index);
            }

            return this.isLargeCell(index) || this.isLargeCell(index + 1);
          },
          isEvenHighSizeByIndex: function (index) {
            if (this.isLessThenMD) {
              return false;
            }

            if (this.isLessThenXL) {
              return this.isLargeCell(index);
            }

            return this.isLargeCell(index - 1);
          },
          getSizeName: function (size) {
            switch (size) {
              case 1:
                return "small";
              case 2:
                return "high";
              case 4:
                return "large";
            }
          },
          resetFirstFoundIndex: function (size) {
            this.firstFoundIndexes[this.getSizeName(size)] = -1;
          },
          setFirstFoundIndex: function (size, index) {
            const prop = this.getSizeName(size);

            if (this.firstFoundIndexes[prop] < 0) {
              this.firstFoundIndexes[prop] = index;
            }
          },
          getFirstFoundIndex: function (size) {
            const prop = this.getSizeName(size);

            if (this.firstFoundIndexes[prop] < 0) return 0;

            return this.firstFoundIndexes[prop];
          },
          getSize: function () {
            if (this.largesCount) return 4;
            if (this.highsCount) return 2;
            return 1;
          },
          getCompleteCellsCount: function (cells) {
            return cells * 4 + cells * 2;
          },
          getBlocks: function (cells) {
            return Math.ceil(cells / this.cellsCountInBlock);
          },
          decSizeCount: function (size) {
            switch (size) {
              case 4:
                this.largesCount--;
                break;
              case 2:
                if (isLastHigh) {
                  this.lastHighsCount--;
                  isLastHigh = false;
                } else {
                  this.highsCount--;
                }
                break;
              case 1:
                this.smallsCount--;
            }
          },
          isExist: function (obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          },
          config: function () {
            this.totalWidth = window.innerWidth;

            if (this.totalWidth >= this.breakpoints.xl) {
              this.cols = 3;
            } else if (this.totalWidth >= this.breakpoints.lg) {
              this.cols = 2;
            } else if (this.totalWidth >= this.breakpoints.md) {
              this.cols = 1;
            } else {
              this.cols = 1;
            }
          },
          restructe(sourceArray) {
            this.config();

            const tempArray = [];

            let toScaleDownLargeSizes = false;
            let isNotFoundSize = false;
            let toSetBeforeEvenLarge = true;
            let beforeEvenLarge;
            let soughtSize;
            let calcSize;
            let isSmallSequence = false;
            let evenStepIndex = 0;
            let sourceIndex;
            let sourceArrayLength = sourceArray.length;
            let sortedCount = 0;

            this.largesCount = 0;
            this.highsCount = 0;
            this.smallsCount = 0;
            this.lastHighsCount = 0;

            let isEvenBlock;
            let blocksCount = 0;
            let cellsCount = 0;
            let lastBlock;
            let restCells = 0;
            let cellIndex = 0;
            let blockIndex = 0;
            let isIncompleteBlock;
            let isIncompleteLarges;
            let isIncompleteSmalls;

            for (let index = 0; index < sourceArrayLength; index++) {
              switch (sourceArray[index].sourceSize) {
                case 4:
                  this.largesCount++;
                  break;
                case 2:
                  this.highsCount++;
                  break;
                case 1:
                  this.smallsCount++;
              }

              cellsCount += sourceArray[index].sourceSize;
              sourceArray[index].sorted = false;
              tempArray.push(sourceArray[index]);
            }

            if (cellsCount < this.getCompleteCellsCount(this.largesCount)) {
              const sourceLargesCount =
                this.smallsCount || this.highsCount
                  ? Math.ceil(this.smallsCount / 2) + this.highsCount
                  : this.largesCount - 1;
              const scaleDownLargesCount = this.largesCount - sourceLargesCount;

              isIncompleteSmalls = true;
            } else {
              blocksCount = this.getBlocks(cellsCount);
            }

            if (this.largesCount || this.highsCount) {
              isIncompleteLarges = this.largesCount < blocksCount;

              if (isIncompleteLarges && this.highsCount) {
                const diff = blocksCount - this.largesCount;

                if (diff <= this.highsCount) {
                  this.lastHighsCount = diff;
                } else {
                  this.lastHighsCount = this.highsCount;
                }

                this.highsCount -= this.lastHighsCount;
              }
            } else {
              toSetBeforeEvenLarge = false;
            }

            lastBlock = blocksCount - 1;

            isIncompleteBlock = !!(cellsCount % this.cellsCountInBlock);

            if (isIncompleteBlock) {
              restCells = cellsCount - lastBlock * this.cellsCountInBlock;
            }

            console.log(sourceArrayLength);
            console.log(cellsCount);
            console.log(blocksCount);
            console.log(lastBlock);
            console.log(restCells);
            console.log(isIncompleteBlock);
            console.log(isIncompleteLarges);

            this.cells = [];

            while (sortedCount < sourceArrayLength) {
              if (!isNotFoundSize) {
                if (isSmallSequence) {
                  if (
                    this.largesCount ||
                    this.highsCount ||
                    this.lastHighsCount
                  ) {
                    isSmallSequence = false;
                  }

                  // if (this.smallsCount) {
                  soughtSize = 1;
                  // } else {
                  //   soughtSize = 2;
                  // }
                } else if (
                  (this.largesCount || this.lastHighsCount) &&
                  this.isLargeSizeByIndex(evenStepIndex)
                ) {
                  if (this.largesCount) {
                    soughtSize = 4;
                  } else {
                    soughtSize = 2;
                    this.isLastHigh = true;
                  }
                } else if (
                  isIncompleteLarges &&
                  this.lastHighsCount &&
                  this.isEvenHighSizeByIndex(evenStepIndex)
                ) {
                  soughtSize = 2;
                  this.isLastHigh = true;
                } else {
                  soughtSize = 0;
                }
              } else {
                isNotFoundSize = false;

                if (soughtSize == 4) {
                  toSetBeforeEvenLarge = false;
                  soughtSize = 2;
                } else if (this.highsCount) {
                  soughtSize = 2;
                } else {
                  soughtSize = 1;
                }
              }

              if (!soughtSize) {
                sourceIndex = 0;
              } else {
                sourceIndex = this.getFirstFoundIndex(soughtSize);
              }

              for (; sourceIndex < sourceArrayLength; sourceIndex++) {
                if (tempArray[sourceIndex].sorted) {
                  continue;
                }

                if (!soughtSize && tempArray[sourceIndex].sourceSize < 3) {
                  soughtSize = tempArray[sourceIndex].sourceSize;

                  console.log(blockIndex);
                  console.log(this.smallsCount);

                  if (
                    soughtSize == 1 &&
                    this.smallsCount > 1
                    // &&
                    // blockIndex < lastBlock
                    // && isIncompleteBlock
                  ) {
                    isSmallSequence = true;
                  }
                  // else if (blockIndex >= lastBlock - 1) {
                  //   if (isIncompleteBlock && !isIncompleteLarges) {
                  //     soughtSize = 2;
                  //   }
                  //   // isNotFoundSize = true;
                  //   // continue;
                  // }
                }

                if (
                  soughtSize == tempArray[sourceIndex].sourceSize ||
                  toScaleDownLargeSizes
                ) {
                  if (!toScaleDownLargeSizes) {
                    calcSize = tempArray[sourceIndex].sourceSize;
                    this.decSizeCount(soughtSize);
                  } else {
                    calcSize =
                      soughtSize <= tempArray[sourceIndex].sourceSize
                        ? soughtSize
                        : tempArray[sourceIndex].sourceSize;
                    this.decSizeCount(tempArray[sourceIndex].sourceSize);
                  }

                  beforeEvenLarge = toSetBeforeEvenLarge
                    ? this.isLargeCell(evenStepIndex + 2)
                    : false;

                  if (calcSize == 2) {
                    evenStepIndex += 2;
                  } else {
                    evenStepIndex++;
                  }

                  this.cells.push({
                    key: this.isExist(tempArray[sourceIndex], "key")
                      ? tempArray[sourceIndex].key
                      : ++this.cellID,
                    sourceSize: tempArray[sourceIndex].sourceSize,
                    calcSize: calcSize,
                    beforeEvenLarge: beforeEvenLarge,
                  });

                  cellIndex += calcSize;
                  blockIndex = Math.floor(cellIndex / this.cellsCountInBlock);

                  this.resetFirstFoundIndex(calcSize);
                  tempArray[sourceIndex].sorted = true;
                  sortedCount++;
                  break;
                } else {
                  this.setFirstFoundIndex(
                    tempArray[sourceIndex].sourceSize,
                    sourceIndex
                  );
                }
              }

              if (sourceIndex >= sourceArrayLength) {
                toScaleDownLargeSizes = true;
                isNotFoundSize = true;
                this.resetFirstFoundIndex(soughtSize);
              }
            }
          },
        },
        created() {
          this.restructe([
            { sourceSize: 1 },
            { sourceSize: 1 },
            { sourceSize: 1 },
            { sourceSize: 1 },
            { sourceSize: 1 },
            { sourceSize: 1 },
            { sourceSize: 1 },
            { sourceSize: 1 },
          ]);
        },
        mounted() {
          $vm = this;

          window.addEventListener("resize", function () {
            if ($vm.timeoutID) {
              clearTimeout($vm.timeoutID);
            }
            $vm.timeoutID = setTimeout(function () {
              $vm.restructe($vm.cells);
            }, 200);
          });
        },
      });
    </script>
  </body>
</html>
